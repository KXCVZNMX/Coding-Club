# 2. Playing with Pygame

Sorry for not going through all contents last Monday, hopefully y'all read
this tomorrow morning.

## A. What is Pygame?

Pygame is a ***library***. In the real world, a library is place where hundreds 
if not thousands of books are stored, and in Python, a library is where
millions of different ***functions***, the magic blackboxes, are stored.

Pygame has a lot of useful functions for us to use in this project. As its 
name suggests, the py***GAME*** library contains functions for us to build
games. There are functions to easily create a window for our game to exist on; 
there are functions to easily draw objects on the screen; and there are lots
more, that I don't even fully understand.

So lets get started.

## B. Import the library

Importing the library is important. Importing a library is like for you to 
physically go to the *library* (The physical one). If you don't *import* the
library, how can you get the books that you need? Similarly, you cannot use
functions that you didn't *import*, you can just make them up and expect 
python to be an omniscient god to *magically* find a function of that name
for you.

To import the pygame library, do this:
```python
import pygame
```

You also want to include another part of this library, containing a lot of 
useful utilities to help us on the way. So import this too:
```python
from pygame.local import *
```

You may realise (if you aren't blind), that the two import statements are quite
different. One is saying `import x`, whilst the other is saying `from x 
import *`. 

The important difference between the former and the ladder are 
that the in the former example, everything that's from `x` are all 
kept in a collection, so when you want to use a function or a property of 
that library, you have to call it as such:
```python
x.foo()
```

In the other example, you don't have to. `from x import *` simply means to
steal everything from `x` and claim it as yourself's (literally). To call 
some function or property of from this import statement, do this:
```python
foo()
```

As you see, we can abbreviate the `x.`, since we just *stole* it and claimed
that we owned it.

### PS:

If when you type `import pygame` into your code editor (VScode I'm assuming), 
and a red line is underlining it, saying something along the lines of "module 
not found...", please execute this in your terminal (press ``ctrl+` `` to enter
if you are on VScode, otherwise search for `cmd` on Windows and `terminal` on
macOS)

Windows:
```powershell
pip install pygame
```

macOS:
```zsh
pip3 install pygame
```

## C. Use the Library

Everything needs *initialisation*. Your parent's cars needs *ignitions*, and 
to power up your phone, you need to *click the power button*. So we gotta
initialise our pygame library as well. To do that, copy this down under your imports:

```python
pygame.init()
```

### C.a Initialise a window

A window here is like a canvas for artists, we need a window to draw stuff 
on it. To do that, copy this:
```python
window = pygame.display.set_mode((800, 600))
```

Ok, this may be a bit complicated for you, but I'll explain.

The `window = ` part should be straight forward. what is does is 
it *assigns* a value to the *variable* ***window***. Having our canvas as a 
variable is beneficial, as we need it later for our *drawing*

The `pygame.` part, is telling Python, we need something from the library
`pygame`. As I've said before we *imported* pygame, and we kept it under their 
name. Hence, we need to call functions from `pygame` using its name as a 
starting.

The `display.set_mode((800, 600))` is probably the most confusing. All you 
have to understand is that `display.set_mode()` is a function that initialises
a screen for us to draw on, and `(800, 600)` is the width and height of 
that screen.

Woah, big success... right?

If you try to run this, what you will encounter is likely an instant quit

#### PS: 

If you can't find where or how to run it, you can type this in the terminal 
to run it (change main.py to whatever file name you put in, a.py, b.py, anything):

Windows:
```powershell
python main.py
```

macOS:
```zsh
python3 main.py
```

Weird, right? Why did it crash?

You can imagine our code as an instruction handbook. What we did here is to 
whoever is using this handbook (the Python interpreter for this instance)
to simply: grab all the relevant libraries, initialise pygame, and draw 
a screen, ***ONCE***, and to shut the program down. 

This is why you are seeing
a single frame (a flash) of the screen. To mitigate this problem, we introduce
the black magic to keep the person (Python) to be always working until we
say stop (Capitalism at its finest). To do this, write this:
```python
while True:
```

This is a `while loop`, and the literally meaning of this code is 
"While True is true, do what every comes after this statement".
As you can see, True, obviously always equals to true, hence, why this is 
an infinite loop.

If you try to run this, you might not be able to quit the program, but don't 
worry just now, you can force quit the program (hopefully you know how) for now.
You do see the black screen though, so that's NICE!

### C.b Be able to quit the program

Pygame's window captures every event (things that are happening) on screen,
every frame that it renders. and `QUIT` is one of the event types. Hence,
this is how to quit the program. Under the while loop (indentation matters)
write this:
```python
for event in pygame.event.get():
    if event.type == QUIT:
        pygame.quit();
```

The `for` loop here is similar to the `while` loop, although with different
so-called *conditions*. Pygame captures events as a list of things, so we 
have to go through the "list of thing" one by one, hence the for loop.

Under the `for` loop, we have the comparison, which compares the type of 
the event, checking whether if it is a QUIT event. You may wonder why the `==` 
is used here instead of a singular `=`. This is because `=` is used for assignments,
as seen previously with the assignment of the `window` variable.

Hooray! now, you can quit the program without any hassle!

You're code should look something like this right now:
```python
import pygame
from pygame.locals import *

pygame.init()

window = pygame.display.set_mode((800, 600))

while True:
    for event in pygame.event.get():
        if event.type == QUIT:
            pygame.quit()
```

## D. Drawing an Object

Drawing an object is very simple with Pygame, and I'll show you how to here.

To Draw something, you need their color; you need their *coordinates* 
(x and y coordinates, if you don't know what it is, search 
*cartesian coordinates* on Google); and their size. After collecting all 
those information, you can now draw an object! Do this under the `for` loop
aligning its indentation with the beginning of the `for` loop:
```python
pygame.draw.rect(window, (255, 255, 255), (400, 300, 50, 50));
```

I'll explain what this does

`pygame.draw.rect()` is a function, that allows us to draw ***rect****angles*.
the function takes a multitude of parameters, but we are only using three here.
The window, the color, and the rect surface.

The window is the `window` variable we've assigned earlier on, which now comes
in handy

The color is in RGB format. As you can see, I've entered `(255, 255, 255)`, 
which is the RGB for *White*.

The rect surface consists of two elements. The first two numbers are the
x and y coordinates of the shape. Which here is simply a placeholder value.
The last two elements are the size of the object, which is simply set to
a size of 50.

This call will draw a 50 by 50 white square at position (400, 300).

Oh no, when you run this, there is nothing on screen??? WHYYYY???

This is because you didn't tell Python to *update* the display. So to do that,
add this underneath:
```python
pygame.display.flip()
```
What your code should look like right now:
```python
import pygame
from pygame.locals import *

pygame.init()

window = pygame.display.set_mode((800, 600))

while True:
    for event in pygame.event.get():
        if event.type == QUIT:
            pygame.quit()
            
    pygame.draw.rect(window, (255, 255, 255), (400, 300, 50, 50))
    pygame.display.flip()
```

## E. Making This Thing Move

To make this move, we need to track the live position of the cube at all times,
how do we do that? Through a variable that can contain two elements.

Place this under your `window` variable:
```python
pos = [400, 300]
```

The square brackets here ([]), acts as a container of the two numbers, 
collecting them into a single place.

Now you should modify your `rect()` function too, since we are not hardcoding
our cube's position anymore! Replace it with:
```python
pygame.draw.rect(window, (255, 255, 255), (pos[0], pos[1], 50, 50))
```

Now you may wonder, why is it `pos[0]` and `pos[1]`? This is because like 
most programming languages, Python is 0-indexed. You don't have to worry 
about that right now, you just have to know, that python starts counting 
from zero, instead of how we start to count from 1. (BTW, pos[x] is saying
to Python that we are looking at the xth element of the list that is pos)

The cube still isn't moving rightnow, since we aren't modifying the value 
the position. To do that, we need to capture keys that are pressed by "us".
This is why pygame comes in handy. Instead of complicated logic, we can 
simply ask pygame to give us every key's state, whether it is pressed
down or not. Put this in your code, above the `rect()` function:

```python
keys = pygame.key.get_pressed()
```

Now we can access these `keys` by indexing into it as such:
```python
    if keys[K_UP]:
        ...
    if keys[K_DOWN]:
        ...
    if keys[K_LEFT]:
        ...
    if keys[K_RIGHT]:
        ...
```

We can read these code as "if keys[something] is pressed, do this..."

Therefore, now, we can implement our logic to move the cube!:

```python
    if keys[K_UP]:
        pos[1] -= 5
    if keys[K_DOWN]:
        pos[1] += 5
    if keys[K_LEFT]:
        pos[0] -= 5
    if keys[K_RIGHT]:
        pos[0] += 5
```

What we are doing here is to move the player's position down if we press up (
counter-intuitive I know, but pygame has the y-axis flipped around), move the
position right when we press right. The value `5` here could be seen as the 
player's speed. modifying this would make the player slower or faster.

Another problem arises now. The trail of your cube isn't getting erased, and
it is filling up the whole screen!

Simple fix here, we just need to fill the screen with whatever the
background color is to reset it! Place this above the rect() method:
```python
window.fill((0, 0, 0));
```

Hell yeah, now you've got a block moving around on an empty screen. Although
it is moving quite fast, erratically. To fix this, we need to cap the 
refresh rate, since that is the determining factor for how fast the game runs.
To do this, we need a clock. Add this before the `while` loop:

```python
clock = pygame.time.Clock()
```

And at the very end of the while loop, add this:
```python
clock.tick(60)
```

This basically caps our frame rate at 60fps.

Ok! Now we have a cube that is freely moving around the black background!

Final Code:
```python
import pygame
from pygame.locals import *

pygame.init()

window = pygame.display.set_mode((800, 600))
pygame.display.set_caption("My Window")

pos = [400, 300]

clock = pygame.time.Clock()

while True:
    for event in pygame.event.get():
        if event.type == QUIT:
            pygame.quit()

    keys = pygame.key.get_pressed()
    if keys[K_UP]:
        pos[1] -= 5
    if keys[K_DOWN]:
        pos[1] += 5
    if keys[K_LEFT]:
        pos[0] -= 5
    if keys[K_RIGHT]:
        pos[0] += 5

    window.fill((0, 0, 0))

    pygame.draw.rect(window, (255, 255, 255), (pos[0], pos[1], 50, 50))
    pygame.display.flip()

    clock.tick(60)
```

Sorry for the late night ping. I forgot to write thing over the week, so I
was just writing it now. Please have a read of this, maybe on your way to school.
Thanks. I gotta go to bed, you may see me visibly tired tomorrow.